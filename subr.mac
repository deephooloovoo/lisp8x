;SUBR.MAC
;@ 86/07/15

;.INCLUDE 8KLISP.DEF

;	EXTRN ERR,PR$PC,MSG$PC,SINIT,TEMP,MKSYM,STEPM,SEARCH,ONE,MEMCHK,PROGN
;	EXTRN MLST,MLSTDE,MSYM,MSYMDE,MNUM,MNUMDE,FLAG,MAP1,LEFT,RIGHT,$KEY
;	EXTRN HEAP,HEAPTR,TSYM,ZERO,BASE,FBASE,CBASE,EQUAL?,SETOPS,BRKEY
;	EXTRN PRINT,SPARE,BOXNUM,UNBOX,UNBXDE,MCHKHL,FADRHL,UNWIND
;	EXTRN MOOV,ADD1,SUB1,MULT0,DIV0,MOD0,SQRT0,MBYTE,MBYTDE,PROTECT

EPROGN:
	CALL MLST
	JP PROGN

REMOB:
	PUSH HL			;SAVE ARGUMENT
	LD DE,PROTECT
	CPDE
	JR C,RM30
	EX DE,HL		;SYMBOL IN DE
	LD HL,HEAP		;HL ON FIRST SYMBOL IN HEAP
	LD BC,7			;OFFSET TO LINK
RM10:
	ADD HL,BC
	PUSH HL			;SAVE PTR TO LAST SYMBOL'S LINK
	FETCH
	CPDE			;FOUND?
	JR Z,RM20		;YES
	LD A,H			;DONE?
	OR A
	INC SP			;DROP
	INC SP
	JR Z,RM30		;YES
	JR RM10
RM20:
	ADD HL,BC
	FETCH			;GET SECOND LINK
	EX DE,HL		;IN DE
	POP HL			;PTR TO FIRST LINK IN HL
	LD (HL),E
	INC HL
	LD (HL),D		;INSERT LINK
RM30:
	POP HL			;RETURN SYMBOL
	RET

REVERSE:
	CALL MLST
	EX DE,HL		;SECOND ARG SHOULD BE NIL
RV10:
	LD A,D
	OR A
	RET Z
	PUSH HL
	EX DE,HL
	POPLIST
	EX (SP),HL
	EX DE,HL
	CALL CONS
	POP DE
	JR RV10

ASSOC:
	CALL MLSTDE		;LIST IN HL
	LD B,D			;ITEM IN BC
	LD C,E
AS10:
	LD A,H			;LIST EMPTY?
	OR A
	RET Z			;YES
	PUSH HL
	CALL CAAR
	LD D,B
	LD E,C
	PUSH BC
	CALL EQUAL?		;CAR EQUAL TO ITEM?
	POP BC
	POP HL
	JR Z,AS20		;YES
	POPLIST
	JR AS10
AS20:
	FETCH
	RET

MEMBER:
	CALL MLSTDE		;LIST IN HL
	LD B,D			;ITEM IN BC
	LD C,E
MB10:
	LD A,H			;LIST EMPTY?
	OR A
	RET Z			;YES
	PUSH HL
	FETCH
	LD D,B
	LD E,C
	PUSH BC
	CALL EQUAL?		;CAR EQUAL TO ITEM?
	POP BC
	POP HL
	RET Z			;YES
	POPLIST
	JR MB10

MEMQ:
	CALL MLSTDE		;LIST IN HL
	LD B,D			;ITEM IN BC
	LD C,E
MQ10:
	LD A,H			;LIST EMPTY?
	OR A
	RET	Z			;YES
	PUSH HL
	FETCH
	CPBC			;CAR EQ TO ITEM?
	POP HL
	RET Z			;YES
	POPLIST
	JR MQ10

MAPC:
	LD A,H			;LIST EMPTY?
	OR A
	RET Z			;YES
	PUSH DE			;SAVE FUNCTION
	POPLIST
	EX (SP),HL		;RESTLIST IN (SP)
	EX DE,HL		;FUNCTION IN DE, ARG IN HL
	CALL MAP1
	POP HL			;RETRIEVE RESTLIST
	JR MAPC

;RETURN NTH ELEMENT OF LIST
NTH:
	CALL NTHCDR
	FETCH
	RET

;RETURN NTH CDR OF LIST
NTHCDR:
	PUSH DE
	CALL UNBOX		;GET NUMBER
	LD B,E			;IN BC
	POP HL
	CALL MLST
NTH10:
	LD A,B			;ZERO?
	OR C
	RET Z			;YES
	POPLIST
	DEC BC
	JR NTH10

;MAKE SINGLE CHARACTER ATOM FROM NUMBER
CHAR:
	CALL MBYTE
	OR 80H			;SET TERMINATOR
	LD HL,(HEAPTR)
	LD DE,9			;OFFSET TO PNAME
	ADD HL,DE
	LD (HL),A
	JP MKSYM		;MAKE SYMBOL

;THROW THE LOCUS OF CONTROL
THROW:
	PUSH HL			;TAG
	EXX				;SAVE VALUE IN DE'
	POP BC			;GET TAG IN BC
	LD HL,(CBASE)	;GET CATCH BASE
	LD DE,(SINIT)	;END OF STACK
TH10:
	CPDE			;ILLEGAL THROW?
	JR NC,THROWERR	;YES
	LD A,C
	CP (HL)			;FOUND TAG?
	INC HL
	JR NZ,TH20		;NO
	LD A,B
	CP (HL)
	JR Z,TH30		;YES
TH20:
	INC HL
	FETCH			;GET CATCH LINK
	JR TH10			;TRY NEXT
TH30:
	INC HL			;FOUND MATCHING TAG
	CALL UNWIND
	LD H,B
	LD L,C			;GET CATCH BASE IN SP
	LD SP,HL
	POP HL
	LD (CBASE),HL	;RESTORE CATCH BASE
	POP HL
	LD (FBASE),HL	;RESTORE FRAME BASE
	EXX
	EX DE,HL		;RETRIEVE VALUE
	RET

THROWERR:
	ERROR("Throw")

;INTERN SYMBOL
INTERN:
	CALL MSYM		;NEED A SYMBOL
	LD BC,9			;OFFSET TO PNAME
	ADD HL,BC
	CALL SEARCH
	RET C			;FOUND
	LD BC,-9
	ADD HL,BC
	EX DE,HL		;INSERT NEW LINK
	LD (HL),D
	DEC HL
	LD (HL),E
	EX DE,HL		;RETURN VALUE
	RET

PLIST:
	CALL MSYM
PLIST2:
	LD BC,5			;OFFSET TO PLIST
	ADD HL,BC
	RET

;PUT PROPERTY LIST
PUTPL:
	CALL PLIST
	JP SET1			;RETURN LIST

;GET PROPERTY LIST
GETPL:
	CALL PLIST
	FETCH
	RET

;PUT PROPERTY
PUT:
	PUSH BC			;SAVE PROPERTY AS RETURN VALUE
	PUSH HL			;SYMBOL
	PUSH BC			;AND PROPERTY AGAIN
	CALL PLIST		;PLIST IN HL
	FETCH
	PUSH HL			;SAVE PLIST
	LD B,D			;KEY IN BC
	LD C,E
	LD A,H
PT10:
	OR A
	JR Z,PT20		;NOT FOUND
	POPLIST
	EX DE,HL
	CPBC			;COMPARE WITH KEY
	EX DE,HL
	JR Z,PT30		;FOUND
	POPLIST
	JR PT10
PT20:
	POP DE			;GET PLIST
	POP HL			;AND PROPERTY
	PUSH BC			;SAVE KEY
	CALL CONS		;CONS PROPERTY AND PLIST
	EX DE,HL
	POP HL			;KEY
	CALL CONS
	EX DE,HL
	POP HL			;SYMBOL
	CALL PLIST2
	LD (HL),E
	INC HL
	LD (HL),D
	POP HL
	RET
PT30:
	POP DE			;DROP PLIST
	POP DE			;GET PROPERTY
	LD (HL),E		;REPLACE
	INC HL
	LD (HL),D
	POP HL			;DROP SYMBOL
	POP HL			;GET PROPERTY
	RET

;GET PROPERTY
GET:
	CALL PLIST		;PLIST IN HL
	FETCH
	LD B,D			;KEY IN BC
	LD C,E
	LD A,H
GT10:
	OR A			;EMPTY?
	RET Z			;YES: NOT FOUND
	POPLIST			;NEXT INDICATOR IN DE
	EX DE,HL
	CPBC
	EX DE,HL
	JR Z,GT20
	POPLIST			;SKIP VALUE
	JR GT10
GT20:
	POPLIST
	EX DE,HL		;RETURN PROPERTY
	RET

PACK:
	CALL MLST
	PUSH HL
	LD HL,(HEAPTR)	;PTR TO NEW STRING
	LD DE,8			;OFFSET TO PNAME-1
	ADD HL,DE
	LD B,H
	LD C,L			;PTR IN BC
	POP HL
PK10:
	POPLIST			;NEXT SYMBOL
	CALL MSYMDE		;IN HL, RESTLIST IN DE
	PUSH DE			;SAVE RESTLIST
	LD DE,8			;OFFSET TO PNAME-1
	ADD HL,DE
PK20:
	INC HL
	LD A,(HL)		;COPY BYTE
	AND 7FH			;CLEAR BIT 7
	INC BC
	LD (BC),A
	BIT 7,(HL)		;DONE?
	JR Z,PK20		;NO
	POP HL			;RETRIEVE RESTLIST
	LD A,H
	OR A			;NIL?
	JR NZ,PK10		;NO
	LD A,(BC)		;ELSE MARK LAST BYTE
	OR 80H
	LD (BC),A
	JP MKSYM

UNPACK:
	CALL MSYM		;NEED A SYMBOL
	PUSH HL			;PUSH IT
	LD DE,8			;CALCULATE INDEX TO END OF PNAME
UP10:
	POP HL
	PUSH HL
	INC DE
	ADD HL,DE
	BIT 7,(HL)
	JR Z,UP10
	PUSH DE			;PUSH INDEX
	LD BC,NIL
	PUSH BC			;PUSH RESULT
UP20:
	POP BC			;RESULT
	POP DE			;INDEX
	POP HL			;SYMBOL
	LD A,8			;DONE?
	CP E
	JR Z,UPRET		;YES
	PUSH HL			;SAVE SYMBOL AGAIN
	ADD HL,DE		;POINT TO NEXT CHAR
	DEC DE			;DECREMENT INDEX
	PUSH DE			;AND SAVE
	PUSH BC
	LD A,(HL)		;MAKE SINGLE-CHAR ATOM
	OR 80H
	LD HL,(HEAPTR)
	LD DE,9
	ADD HL,DE
	LD (HL),A
	CALL MKSYM
	POP DE			;RESULT UTIL NOW
	CALL CONS
	PUSH HL			;SAVE NEW RESULT
	JR UP20			;CONTINUE
UPRET:
	LD H,B			;GET RESULT
	LD L,C
	RET

;SET VALUE
SET:
	CALL MSYM
SET0:
	INC HL
SET1:
	LD (HL),E
	INC HL
	LD (HL),D
	EX DE,HL
	RET

;RETRIEVE FUNCTION DEFINITION
GETD:
	CALL MSYM
	INC HL
	INC HL
	INC HL
	FETCH
	LD A,H
	OR A			;NIL?
	RET Z			;YES
	CP HIHEAP		;CODE?
	RET NC			;NO
	JP BOXHL

;SET FUNCTION DEFINITION
PUTD:
	JP DOPUTD

;SINGLE STEP MODE
STEP:
	LD A,3			;SET STEPMODE
	JR RN10
RUN:
	XOR A			;CLEAR STEPMODE
RN10:
	LD (STEPM),A
	RET

;DESTRUCTIVE REPLACEMENT
RPLCA:
	CALL MLST
	LD (HL),E
	INC HL
	LD (HL),D
	DEC HL
	RET

MPCAN:
	LD A,H			;LIST EMPTY?
	OR A
	RET Z			;YES
	PUSH DE			;SAVE FUNCTION
	POPLIST
	EX (SP),HL		;CDR IN (SP)
	EX DE,HL		;FUNCTION IN DE, CAR IN HL
	CALL MAP1		;APPLY FUNCTION TO CAR
	EX (SP),HL		;SAVE RESULT, GET CDR
	CALL MPCAN		;RECURSE
	EX DE,HL
	POP HL
NCONC:
	LD A,H			;FIST LIST EMPTY?
	OR A
	JR NZ,NC10		;NO
	EX DE,HL		;ELSE RETURN SECOND LIST
	RET
NC10:
	CALL MLST
	PUSH HL			;SAVE RETURN VALUE
	LD BC,MAXLST
	PUSH DE			;SAVE SECOND LIST
NC20:
	LD D,H			;SAVE PTR
	LD E,L
	CALL CDR
	LD A,H
	OR A			;END OF FIRST LIST?
	JR Z,NC30		;YES
	DEC C
	JR NZ,NC20		;CHECK FOR CIRCULAR LIST
	DJNZ NC20
TOOLONG:
	ERROR("Circ")
NC30:
	EX DE,HL		;GET PTR TO LAST CELL IN HL
	POP DE			;RETRIEVE SECOND LIST
	JR RPLCD2		;REPLACE CDR

RPLCD:
	CALL MLST
	PUSH HL
RPLCD2:
	INC HL
	INC HL
	LD (HL),D
	INC HL
	LD (HL),E
	POP HL
	RET

;SYSTEM CALLS
BIOS:
	CALL MBYTE		;OFFSET
	LD HL,BOXA		;PUSH RETURN ADDRESS
	PUSH HL
	LD HL,(01)		;GET BOOT ADDRESS
	ADD A,L			;ADD OFFSET
	LD L,A
	ADC A,H
	SUB L
	LD H,A
	PUSH HL			;SAVE JUMP ADR
	PUSH BC			;SAVE DE-VALUE
	CALL UNBXDE		;GET BC-VALUE
	LD B,E
	POP HL			;DE-VALUE
	PUSH BC			;SAVE BC-VALUE
	CALL UNBOX		;GET DE-VALUE
	LD D,E
	LD E,C
	POP BC
	RET

BDOS:
	CALL MBYTE		;GET SYSTEM CALL NUMBER
	LD C,A
	LD A,D			;SECOND ARG?
	OR A
	JR Z,BD10		;NO
	PUSH BC
	CALL UNBXDE		;ELSE GET ARGUMENT
	LD D,E			;IN DE
	LD E,C
	POP BC
BD10:
	CALL 5			;CALL BDOS
	JR BOXHL

;MEMORY ACCESS OPERATOR
AT_OP:
	PUSH DE			;SAVE SECOND ARG
	CALL UNBOX		;GET ADDRESS
	LD B,E			;IN BC
	LD A,(BC)		;PEEK BYTE
	LD L,A
	POP DE			;SECOND ARG
	LD A,D
	OR A			;EMPTY?
	JR Z,BOXL		;YES
	CALL MBYTDE		;GET BYTE
	LD (BC),A		;POKE NEW VALUE
	EX DE,HL
	JR BOXL			;RETURN OLD VALUE

LENGTH:
	LD DE,0			;INIT COUNT
	LD BC,MAXLST
LN10:
	LD A,H			;EMPTY?
	OR A
	JR Z,BOXDE		;YES
	LD A,(HL)
	RRCA			;ATOMIC?
	JR NC,BOXDE		;YES
	INC DE
	CALL CDR2
	EX DE,HL
	CPBC			;MAX?
	JR Z,TOOLONG	;YES
	EX DE,HL
	JR LN10

MFREE:
	LD HL,-SAFETY	;RESERVE SAFETY SPACE
	ADD HL,SP
	LD BC,(HEAPTR)
	SBC HL,BC
	JR BOXHL

RADIX:
	CALL MBYTE		;NEED BYTE
	LD HL,BASE+1
	LD B,(HL)		;GET OLD RADIX
	LD (HL),A		;SET NEW ONE
BOXB:
	LD L,B
	JR BOXL

;RAW CONSOLE INPUT
KEY:
	CALL $KEY
;	JR Z,KEY
	JR BOXA

;RETURN ASCII VALUE OF FIRST CHAR
ASCII:
	CALL MSYM
	LD DE,9				;OFFSET TO PNAME
	ADD HL,DE
	LD A,(HL)
	AND 7FH				;STRIP MSB
BOXA:
	LD L,A
BOXL:
	LD H,0
BOXHL:
	EX DE,HL
BOXDE:
	LD C,0			;ZERO HIGHEST BYTE
;****************************;
; BOX UNSIGNED NUMBER IN CDE ;
;****************************;
BOXCDE:
	LD HL,(HEAPTR)
	INC HL			;SKIP TAG BYTE
	XOR A
	CP C			;HIGHEST BYTE
	JR Z,BH10
	LD (HL),3
	JR BH40
BH10:
	CP D			;MIDDLE BYTE
	JR Z,BH20
	LD (HL),2
	JR BH40
BH20:
	CP E			;LOWEST BYTE
	JR Z,BH30
	LD (HL),1
	JR BH40
BH30:
	LD (HL),0		;ALL ZERO
	JR BOXRET
BH40:
	INC HL
	LD (HL),E		;STORE 3 BYTES
	INC HL
	LD (HL),D
	INC HL
	LD (HL),C
BOXRET:
	JP BOXNUM

MUST2NUM:
	CALL MNUM
	EX DE,HL
	CALL MNUM
	EX DE,HL
	RET

;*************;
; ARITHMETICS ;
;*************;
ONEADD:
	LD DE,ONE
ADD:
	CALL MUST2NUM
	PUSH HL
	CALL SETOPS
	EX DE,HL
	POP HL
	INC HL
	LD A,(DE)
	XOR (HL)
	JP M,ADD10
	CALL ADD1
	JP BOXNUM
ADD10:
	CALL SUB1
	JP BOXNUM

ONESUB:
	LD DE,ONE
SUB:
	LD A,D			;NEGATION?
	OR A
	JR Z,NEGATE
	CALL MUST2NUM
	PUSH DE
	EX DE,HL
	CALL SETOPS
	EX DE,HL
	POP HL
	INC HL
	LD A,(DE)
	XOR (HL)
	JP P,ADD10
	CALL ADD1
	JP BOXNUM

NEGATE:
	CALL MNUM
	EX DE,HL
	CALL SETOPS
	LD A,(HL)
	OR A
	JR Z,NG10
	XOR 80H
	LD (HL),A
NG10:
	JP BOXNUM

MULT:
	CALL MUST2NUM
	PUSH HL
	CALL SETOPS
	EX DE,HL
	POP HL
	INC HL
	CALL MULT0
	JP BOXNUM

DIV:
	CALL MUST2NUM
	PUSH DE
	EX DE,HL
	CALL SETOPS
	EX DE,HL
	POP HL
	INC HL
	CALL DIV0
	JP BOXNUM

MODLS:
	CALL MUST2NUM
	PUSH DE
	EX DE,HL
	CALL SETOPS
	EX DE,HL
	POP HL
	INC HL
	CALL MOD0
	JP BOXNUM

SQRT:
	CALL MNUM
	EX DE,HL
	CALL SETOPS
	EX DE,HL
	CALL SQRT0
	JP BOXNUM

HALF:
	CALL MNUM
	EX DE,HL
	CALL SETOPS
	CALL RIGHT
	JP BOXNUM

DOUBLE:
	CALL MNUM
	EX DE,HL
	CALL SETOPS
	CALL LEFT
	JP BOXNUM

ABS:
	CALL MNUM
	EX DE,HL
	CALL SETOPS
	RES 7,(HL)
	JP BOXNUM

;SHOW STACK
SS:
	LD HL,(SINIT)
	LD DE,-4		;SKIP RET TO CP/M AND TOP-LEVEL REVALO READ CHANNEL
	ADD HL,DE
	PUSH HL			;STACK INDEX
SS10:
	POP HL
	PUSH HL
	LD BC,-7		;DON'T COUNT RET-ADR, INDEX AND BREAK-REVALO READ CHANNEL
	ADD HL,BC		;(CARRY SET)
	SBC HL,SP		;DONE?
	POP HL			;GET INDEX
	JR C,TRET		;YES
	DEC HL			;NEXT STACK ENTRY
	LD D,(HL)
	DEC HL
	LD E,(HL)
	PUSH HL			;SAVE INDEX
	CPDE			;FRAME LINK?
	JR C,SS10		;YES: PRINT NOTHING
	LD A,D			;UNBOUND VALUE?
	OR E
	JR NZ,SS15		;NO
	MSG("[void]")
	JR SS10
SS15:
	LD A,D			;NIL?
	OR A
	JR Z,SS20		;YES
	CP HIHEAP		;CODE?
	JR C,SS10		;YES - PRINT NOTHING
SS20:
	EX DE,HL		;PRINT ITEM
	LD DE,NIL		;TO CONSOLE
	CALL PRINT
	CALL BRKEY		;ESC?
	JR NC,SS10		;NO
	POP HL
	JR NILRET		;ELSE RETURN NIL

;**********************;
; TEST FOR END OF FILE ;
;**********************;
EOFP:
	CALL FADRHL
	LD A,(DE)
	AND 10H			;BIT 4?
	JP NZ,TRET		;YES
	JP NILRET

;*******************;
; CONDITIONAL TESTS ;
;*******************;
ATOM:
	LD A,H			;NIL?
	OR A
	JR Z,TRET		;YES->ATOM
	BIT 0,(HL)
	JR Z,TRET
	JR NILRET

PAIR:
	BIT 0,(HL)
	JR NZ,TRET
	JR NILRET

SYMBOL:
	LD A,(HL)
	AND 81H
	JR Z,TRET
	JR NILRET

BOUNDP:
	CALL MSYM
	INC HL
	LD A,(HL)
	INC HL
	OR (HL)
	JR NZ,TRET
	JR NILRET

NUMBER:
	LD A,(HL)
	AND 81H
	CP 80H
	JR Z,TRET
	JR NILRET

EQUAL:
	CALL EQUAL?
	JR Z,TRET
	JR NILRET

C_EQ:
	CPDE			;POINTER EQUALITY?
	JR NZ,NILRET	;NO
;**********;
; RETURN T ;
;**********;
TRET:
	LD HL,TSYM
	RET

L_NOT:
	LD A,H
	OR A
	JR Z,TRET
;************;
; RETURN NIL ;
;************;
NILRET:
	LD HL,NIL
	RET

ZEROP:
	CALL MNUM
	INC HL
	LD A,(HL)
	OR A
	JR Z,TRET
	JR NILRET

MINUSP:
	CALL MNUM
	INC HL
	BIT 7,(HL)
	JR NZ,TRET
	JR NILRET

ODDP:
	CALL MNUM
	INC HL
	LD A,(HL)
	OR A			;ZERO?
	JR Z,NILRET
	INC HL
	BIT 0,(HL)
	JR NZ,TRET
	JR NILRET

;COMPARE LISTS
LSTLT:
	LD A,H			;FIRST ARG NIL?
	OR A
	RET Z			;YES: RETURN NIL
	FETCH			;CAR OF FIRST ARG
	EX DE,HL
	CALL CAR		;AND OF SECOND (TYPE CHECK)
	EX DE,HL

;COMPARE NUMBERS, SYMBOLS OR LISTS
LESSP:
	LD A,(HL)		;FIRST ARG
	RRCA			;LIST?
	JR C,LSTLT		;YES
	AND 40H			;SYMBOL?
	JR Z,SYMLT		;YES
	CALL MUST2NUM	;ELSE MUST BE 2 NUMBERS
	EX DE,HL
	INC HL
	INC DE
	CALL SPARE
	JR C,TRET
	JR NILRET

;COMPARE SYMBOLS
SYMLT:
	CPDE			;EQUAL?
	JR Z,NILRET		;YES: NOT LESS
	LD BC,8			;OFFSET TO PNAME-1
	ADD HL,BC
	CALL MSYMDE		;SECOND ONE MUST BE A SYMBOL, TOO
	ADD HL,BC		;ADD OFFSET
SLT10:
	INC DE
	INC HL
	LD A,(DE)		;GET CHAR FROM FIRST ARG
	AND 7FH
	LD B,A
	LD A,(HL)		;COMPARE TO CHAR FROM SECOND
	AND 7FH
	CP B
	JR Z,SLT20		;CHARS ARE EQUAL
	JR C,NILRET
	JR TRET
SLT20:
	LD A,(DE)
	RLA				;END OF FIRST?
	JR C,TRET		;YES: SECOND NOT ENDED (NOT EQUAL)
	LD A,(HL)
	RLA				;END OF SECOND?
	JR C,NILRET		;YES:
	JR SLT10

MAXMIN:
	PUSH HL			;SAVE ARGS
	PUSH DE
	CALL LESSP		;COMPARE
	LD A,H			;GET RESULT
	POP DE
	POP HL
	OR A
	RET

MAX:
	CALL MAXMIN		;FIRST LESS THAN SECOND?
	RET Z			;NO: RETURN FIRST
	EX DE,HL		;ELSE RETURN SECOND
	RET

MIN:
	CALL MAXMIN		;FIRST LESS THAN SECOND?
	RET NZ			;YES: RETURN FIRST
	EX DE,HL		;ELSE RETURN SECOND
	RET

DELETE:
	CALL MLSTDE
DL10:
	LD A,H			;EMPTY?
	OR A
	RET Z			;YES
	PUSH HL
	PUSH DE
	PUSH HL
	FETCH			;CAR
	CALL EQUAL?
	POP HL
	POPLIST
	POP DE
	JR Z,DL20
	CALL DL10		;RECURSE
	EX DE,HL
	POP HL
	FETCH			;CAR
	JR CONS
DL20:
	POP DE			;DROP
	RET				;RETURN CDR

APPEND:
	LD A,H			;FIRST LIST EMPTY?
	OR A
	JR NZ,AP10		;NO
	EX DE,HL		;ELSE RETURN SECOND LIST
	RET
AP10:
	CALL MLST
	PUSH HL
	FETCH
	EX (SP),HL		;SAVE CAR IN STACK
	CALL CDR2		;GET CDR
	CALL APPEND		;RECURSE
	JR POPAP		;CONS WITH CAR

MPCAR:
	LD A,H			;LIST EMPTY?
	OR A
	RET Z			;YES
	PUSH DE			;SAVE FUNCTION
	POPLIST
	EX (SP),HL		;CDR IN (SP)
	EX DE,HL		;FUNCTION IN DE, CAR IN HL
	CALL MAP1		;APPLY FUNCTION TO CAR
	EX (SP),HL		;SAVE RESULT, GET CDR
	CALL MPCAR		;RECURSE
POPAP:
	EX DE,HL
	POP HL
;******************;
; LIST CONSTRUCTOR ;
;******************;
CONS:
	LD B,H			;COPY CAR
	LD C,L
	LD HL,(HEAPTR)
	PUSH HL			;SAVE RETURN VALUE
	LD (HL),C		;STORE CAR
	INC HL
	LD (HL),B
	INC HL
	LD (HL),D
	INC HL
	LD (HL),E
	INC HL
	LD (HEAPTR),HL
	CALL MCHKHL
	POP HL
	RET

NILCONS:
	LD DE,NIL
	JR CONS

;*****************;
; LIST OPERATIONS ;
;*****************;
CAAAR:
	CALL MLST
	FETCH
	JR CAAR
CAADR:
	CALL MLST
	POPLIST
CAAR:
	CALL MLST
	FETCH
	JR CAR
CADAR:
	CALL MLST
	FETCH
	JR CADR
CADDR:
	CALL MLST
	POPLIST
CADR:
	CALL MLST
	POPLIST
CAR:
	CALL MLST
	FETCH
	RET

CDAAR:
	CALL MLST
	FETCH
	JR CDAR
CDADR:
	CALL MLST
	POPLIST
CDAR:
	CALL MLST
	FETCH
	JR CDR
CDDAR:
	CALL MLST
	FETCH
	JR CDDR
CDDDR:
	CALL MLST
	POPLIST
CDDR:
	CALL MLST
	POPLIST
CDR:
	CALL MLST
CDR2:
	INC HL
	INC HL
	LD A,(HL)
	INC HL
	LD L,(HL)
	LD H,A
	RET

	END
