;INOUT.MAC
;16nov86abu

;.INCLUDE 8KLISP.DEF

;	EXTRN MLST,MSYM,MSYMDE,MNUM,BOXHL,BOXCDE,MKSYM,MBYTE
;	EXTRN CONS,NILCONS,ERR,MCHKHL,UNBOX,CPYSYM,$KEY,BRKEY
;	EXTRN LBP,NXTCHR,LDFLG,IOCHAN,SEARCH,CMPSTR,RESET
;	EXTRN HEAPTR,TEMP,FLAG,HEAP,T1,T2,SINIT,NILRET
;	EXTRN BASE,SHORT,QUOTSYM,FILMAX,LEVEL,INTSYM
;	EXTRN ADD1,MULT0,MOOV,MOD0,PSHL,ZERO,ONE

;ERASE FILE
ERA:
	PUSH HL			;SAVE FILE NAME AS RETURN VALUE
	LD DE,T1		;SPACE FOR FCB
	CALL FFCB1		;FORMAT FCB
	BDOS(19)			;DELETE FILE
ERARET:
	POP HL
	CP 255			;FOUND?
	RET NZ			;YES
	JP NILRET		;ELSE RETURN NIL

;RENAME FILE
REN:
	PUSH DE			;SAVE NEW NAME
	LD DE,T1		;SET OLD NAME
	CALL FFCB1
	LD DE,T1+16
	POP HL			;NEW NAME
	PUSH HL			;SAVE AS RETURN VALUE
	CALL FFCB1
	LD DE,T1+16		;ERASE NEW IF EXISTENT
	BDOS(19)
	LD DE,T1
	BDOS(23)		;RENAME
	JR ERARET

;****************;
; SELECT CONSOLE ;
;****************;
SELCON:
	LD DE,NIL
	LD (IOCHAN),DE
	RET

;**********************;
; RETURN FILE POSITION ;
;**********************;
WHERE:
	CALL FADRMN		;GET FILE PTR
	INC DE
	LD A,(DE)		;GET COUNT
	LD HL,34		;OFFSET TO R0
	ADD HL,DE
	ADD A,A			;SHIFT A LEFT
	LD D,(HL)		;MIDDLE BYTE
	INC HL
	LD C,(HL)		;HIGHEST BYTE
	SRL C			;SHIFT ALL RIGHT
	RR D
	RRA
	LD E,A			;LOWEST BYTE
	JP BOXCDE

;********************
; SET FILE POSITION ;
;*******************;
SEEK:
	.echoln "seek ",$
	PUSH HL			;SAVE POS AS RETURN VALUE
	EX DE,HL
	CALL FADRMN		;FILE IN DE (POS IN HL)
	PUSH DE			;SAVE FILE PTR
	call UNBOX
	pop hl
	ld e,(hl)
	inc hl
	ld d,(hl)
	ex de,hl
	add hl,bc
	ex de,hl
	ld (hl),d
	dec hl
	ld (hl),e
	pop hl
	ret
	ex de,hl
	ld (hl),e
	inc hl
	ld (hl),d
	pop hl
	ret
	LD A,(DE)		;OPEN FOR READING OR WRITING?
	AND 3
	JP Z,FILERR		;NO
	LD A,(DE)
	OR 3			;ELSE SET READ AND WRITE
	LD (DE),A
	CALL UNBOX		;GET NUMBER INTO DEC
	SLA C			;ADJUST RECORD
	RL E
	RL D
	SRL C
	POP HL			;FILE PTR
	PUSH HL
	INC HL			;SET NEW COUNT
	LD (HL),C
	LD BC,34		;OFFSET TO R0
	ADD HL,BC
	FETCH			;GET RANDOM RECORD NO
	CPDE			;SAME?
	POP HL
	JR Z,SKRET		;YES
	PUSH DE			;SAVE NEW RECORD NO
	CALL WRREC		;ELSE WRITE RECORD IF NECESSARY
	RES 2,(HL)		;CLEAR LOADED FLAG
	LD BC,35		;OFFSET TO R0
	ADD HL,BC
	POP DE
	LD (HL),E		;SET NEW RECORD NO
	INC HL
	LD (HL),D
SKRET:
	POP HL			;RETURN NEW POSITION
	RET

;********************;
; CALCULATE FILE ADR ;
;********************;
FADRMN:
	CALL MNUM		;CONSOLE NOT ALLOWED
FADRHL:
	EX DE,HL
FADRDE:
	PUSH HL			;PRESERVE HL
	EX DE,HL		;CHANNEL NO IN HL
	LD A,H			;NIL?
	OR A
	JR Z,FA20		;YES
	CALL MBYTE
	JP NZ,FILERR
	LD HL,FILMAX
	CP (HL)			;LEGAL FILE NO?
	JP NC,FILERR	;NO
	LD HL,(SINIT)
	OR A
	JR Z,FA20		;CORRECT ADR
FA10:
	LD DE,FILSIZ
	ADD HL,DE
	DEC A
	JR NZ,FA10
FA20:
	EX DE,HL		;FILE ADR IN DE
	POP HL			;RESTORE HL
	RET

;***************************;
; FORMAT FILE CONTROL BLOCK ;
;***************************;
FFCB:
	LD A,H			;NIL?
	OR A
	JR Z,ALLWILD	;YES
FFCB1:
	CALL MLST
	PUSH DE			;SAVE PTR TO FCB
;	PUSH DE
	POPLIST			;NAME IN DE
	;EX (SP),HL		;SAVE REST OF ARGS, FCB IN HL
	;LD B,8			;SIZE FILE NAME
	ld hl,8
	add hl,de		;bc holds name
	B_CALL(_Mov9ToOP1)
	ld a,5
	ld (OP1),a
	B_CALL(_ChkFindSym)
	pop hl			;check if symbol exists
;	ex de,hl
	ld (hl),e
	inc hl
	ld (hl),d
	ret
	CALL FNAME
	POP HL			;RETRIEVE REST
	PUSH DE
	POPLIST			;NAME IN DE
	EX (SP),HL		;SAVE REST OF ARGS, FCB IN HL
	LD B,3			;SIZE FILE TYPE
	CALL FNAME
FF10:
	LD B,24			;REST OF FCB
	XOR A			;FILL WITH ZERO
FF20:
	INC DE
	LD (DE),A
	DJNZ FF20
	POP HL
	FETCH			;RETRIEVE POSSIBLE DRIVE SPECIFIER
	POP DE			;AND FCB PTR
	LD A,H			;NIL?
	LD (DE),A
	OR A
	RET Z			;YES - DEFAULT DRIVE
	LD BC,9
	ADD HL,BC		;HL ON NAME
	LD A,(HL)		;GET FIRST LETTER
	AND 1FH			;DRIVE NUMBER
	LD (DE),A
	RET

ALLWILD:
	PUSH DE
	PUSH HL
	LD B,11
	CALL FWILD
	JR FF10

;SET FILE NAME PART
FNAME:
	LD A,D			;NIL?
	OR A
	JR Z,FNNIL		;YES
	CALL MSYMDE		;DE ON FCB, HL ON SYMBOL
	ld de, OP1
	PUSH BC			;SAVE COUNT
	LD BC,9			;OFFSET TO NAME
	ADD HL,BC		;HL ON NAME
	POP BC			;RETRIEVE COUNT
FN10:
	LD A,(HL)		;NEXT CHAR
	AND 7FH
	CP '*'			;WILD CARD?
	JR Z,FWILD
	CP 'z'+1		;TO UPPER
	JR NC,FN20
	CP 'a'
	JR C,FN20
	SUB 32
FN20:
	INC DE
	LD (DE),A
	LD A,(HL)
	RLCA			;LAST CHAR IN NAME?
	JR C,FBLANK		;YES
	INC HL
	DJNZ FN10		;ELSE CONTINUE
	RET
FNNIL:
	EX DE,HL		;FCB IN DE
	INC B			;DUMMY INCREMENT
FBLANK:
	LD A,' '		;FILL WHITH BLANKS
	JR NFILL
FWILD:
	LD A,'?'		;WILD CARD CHARACTER
	INC B
NFILL:
	DEC B			;DONE?
	RET Z			;YES
	INC DE			;ELSE FILL WITH BLANKS
	LD (DE),A
	JR NFILL

;READ RECORD
RDREC:
	BIT 2,(HL)		;ALREADY LOADED?
	RET NZ			;YES
	PUSH HL			;SAVE FILE ADR
	LD DE,38		;OFFSET TO BUFFER
	ADD HL,DE
	EX DE,HL		;BUFFER ADR IN DE
	BDOS(26)			;SET DMA
	POP DE			;FILE ADR
	PUSH DE
	INC DE			;FCB ADR
	INC DE
	BDOS(33)			;READ RANDOM
	POP HL			;RETRIEVE FILE ADR
	SET 2,(HL)		;SET LOADED
	OR A			;READ PAST EOF?
	RET Z			;NO
	SET 4,(HL)		;ELSE SET EOF
	RET

;WRITE RECORD
WRREC:
	BIT 3,(HL)		;WRITTEN?
	RET Z			;NO
	PUSH HL			;SAVE FILE ADR
	LD DE,38		;OFFSET TO BUFFER
	ADD HL,DE
	EX DE,HL		;BUFFER ADR IN DE
	BDOS(26)		;SET DMA
	POP DE			;FILE ADR
	PUSH DE
	INC DE			;FCB ADR
	INC DE
	BDOS(34)			;WRITE RANDOM
	POP HL			;RETRIEVE FILE ADR
;	CP 5			;DIRECTORY FULL?
;	JR Z,DSKFUL		;YES
;	CP 6			;PHYSICAL END OF DISK?
;	JR Z,DSKFUL		;YES
 OR A
 JR NZ,DSKFUL
	SET 2,(HL)		;SET LOADED
	RES 3,(HL)		;CLEAR WRITTEN
	RET
DSKFUL:
	ERROR("Disk")

NILNAM:
	DC "NIL",0

INIBUF:
	XOR A
	LD (LBUF),A
	LD A,' '		;BLANK IN NEXTCHAR
	LD (NXTCHR),A
CLRBUF:
	XOR A
	LD (LDFLG),A	;CLEAR LOAD FLAG
CLRBF2:
	LD HL,LBUF
CB10:
	LD (LBP),HL		;INIT LINE BUFFER PTR
	LD A,(HL)		;FIND END OF LINE
	OR A
	RET Z
	INC HL
	JR CB10

;READ LIST
RDLIST:
	CALL SKIPW
	CP ')'			;END OF LIST?
	JR NZ,RL10		;NO
	CALL GETCHR		;ELSE DISCARD ')'
	JP RETNIL		;RETURN NIL
RL10:
	CP '>'			;END OF SUPER-LIST?
	JP Z,RETNIL		;YES
	CP '.'			;DOTTED PAIR?
	JR NZ,RL20		;NO
	CALL GETCHR		;DISCARD '.'
	CALL READ0		;READ EXPR
	PUSH HL
	CALL SKIPW
	CP '>'			;SUPER?
	JR Z,RL15		;YES
	CALL GETCHR		;ELSE NEED ')'
	CP ')'
RL15:
	POP HL			;RETURN VALUE
	RET Z
READERR:
	ERROR("Read")
RL20:
	CALL READ0
	PUSH HL
	CALL RDLIST
RL30:
	EX DE,HL
	POP HL
	JP CONS

RDSUPER:
	CALL RDLIST		;READ LIST
	CALL GETCHR
	CP '>'			;WAS IT A SUPER-LIST?
	RET Z			;YES
	JR READERR		;ELSE DROP '>'

RDQUOTE:
	LD HL,QUOTSYM
	PUSH HL
	CALL READ0
	CALL NILCONS
	JR RL30

;LBUF:
	.db "( + 1 2 )", 26 ,0
;READ ONE EXPRESSION
READ:
;	B_CALL(_GetStringInput2)
	CALL FADRHL		;GET FILE ADDR
	LD (IOCHAN),DE	;IN I/O CHANNEL
	CALL READ0		;READ ONE EXPRESSION
;	ret
	JP SELCON		;CLEAR I/O CHANNEL

READ0:
	.echoln "read0 ",$
	CALL GTNONW			;SKIP POSSIBLE LEADING WHITE SPACE AND GET ONE CHAR
	CP ')'				;IGNORE CLOSING PAREN
	JR Z,READ0
	CP '>'
	JR Z,READ0
	CP '('				;OPEN PAREN?
	JR Z,RDLIST			;YES-JMP
	CP '<'				;SUPER-BRACKET?
	JR Z,RDSUPER		;YES
	CP "'"				;QUOTE?
	JR Z,RDQUOTE		;YES-JMP
;ATOM: SCAN ONE TOKEN FROM INPUT STREAM INTO HEAP
	LD HL,FLAG		;PRESERVE FIRST CHAR IN A
	LD (HL),0		;CLEAR FLAG: ASSUME VALID NUMBER
	LD HL,(HEAPTR)
	LD DE,9			;OFFSET TO PNAME
	ADD HL,DE
	PUSH HL			;KEEP STRING START ADDRESS
	LD (HL),A		;SAVE FIRST CHAR
	CP '-'
	JR Z,TK40		;SKIP IF POSSIBLY NUMBER
TK10:
	SUB '0'
	JR C,TK30		;< '0' -> NO NUMBER
	CP 10
	JR C,TK20		;<= '9' -> TEST AGAINST RADIX
	CP 17
	JR C,TK30		;< 'A' -> NO NUMBER
	SUB 7
TK20:
	PUSH HL
	LD HL,BASE+1
	CP (HL)
	POP HL
	JR C,TK40
TK30:
	LD (FLAG),A		;CANNOT BE A NUMBER
TK40:
	LD A,(NXTCHR)	;TEST FOR END OF NAME
	CP 33			;WHITE SPACE?
	JR C,TK50		;YES-JMP
	CP ')'			;CLOSING PAREN?
	JR Z,TK50		;YES-JMP
	CP '>'
	JR Z,TK50
	CP '.'			;DOT?
	JR Z,TK50		;YES-JMP
	CALL GETCHR		;NO-NEXT CHAR
	INC HL			;INC PTR
	LD (HL),A		;SAVE CHAR
	JR TK10			;CONTINUE
	;END OF NAME
TK50:
	INC HL
	LD (HL),0
;	SET 7,(HL)		;END-OF-STRING MARK; WHO THE HELL DOES THIS
	POP HL			;PTR TO START OF NAME
	LD DE,NILNAM
	CALL CMPSTR
	JR NZ,RD10
RETNIL:
	LD HL,NIL			;RETURN NIL
	RET
RD10:
	CALL SEARCH
	RET C				;FOUND

	;NOT FOUND, TEST FOR NUMBER
NOTFND:
	LD A,(FLAG)
	OR A
	JR Z,MKNUM
	;NOT A NUMBER, MAKE NEW SYMBOL
	PUSH DE			;SAVE PTR TO LAST LINK
	CALL MKSYM		;MAKE NEW SYMBOL
	POP DE
	LD A,(INTSYM+2)	;INTERN THE NEW SYMBOL?
	OR A
	RET Z			;NO
	EX DE,HL		;ELSE INSERT NEW LINK
	LD (HL),D
	DEC HL
	LD (HL),E
	EX DE,HL		;RETURN VALUE
	RET

;CONVERT STRING TO A NUMBER
MKNUM:
	EX DE,HL		;DE POINTS TO STRING
	LD HL,(HEAPTR)	;HL INTO HEAP
	INC HL			;SPACE FOR LENGTH
	LD (HL),0		;INIT VALUE TO ZERO
	LD A,(DE)		;FIRST CHAR
	CP '-'
	PUSH AF			;SAVE SIGN
	JR NZ,MN10
	INC DE			;SKIP MINUS SIGN
MN10:
	EX DE,HL		;DE ON NUMBER
MN20:
	PUSH HL			;SAVE PTR TO STRING
	LD HL,BASE		;HL ON RADIX NODE
	CALL MULT0
	POP HL
	PUSH HL
	LD A,(HL)		;NEXT CHAR
	AND 7FH			;CLEAR MARK
	SUB '0'			;MAKE BINARY
	JR Z,MN35		;JMP IF ZERO
	CP 10
	JR C,MN30
	SUB 7
MN30:
	LD HL,SHORT+1
	LD (HL),A
	DEC HL			;HL ON SHORT
	CALL ADD1
MN35:
	POP HL
;	BIT 7,(HL)		;END OF STRING? ;AGAIN, WHAT THE HELL
;	INC HL
	push bc
	ld b,a
	inc hl
	LD A ,(HL)
	OR A
	ld a,b
	pop bc
;	dec hl
	JR NZ,MN20		;NO
	POP AF			;GET SIGN
	JR NZ,BOXNUM	;SKIP IF POSITIVE
	LD A,(DE)
	OR A			;VALUE ZERO?
	JR Z,BOXNUM		;YES
	OR 80H			;ELSE SET NEGATIVE
	LD (DE),A
;******************************;
; BOX NUMBER GENERATED IN HEAP ;
;******************************;
BOXNUM:
	.echoln "boxnum ", $
	LD HL,(HEAPTR)
	INC HL				;GET LENGTH
	LD A,(HL)
	OR A				;ZERO?
	JR Z,BOXZERO		;YES
	ADD A,6				;3 BYTES + ADJUSTMENT TO MULTIPLE OF 4
	AND 07CH
	LD C,A				;SAVE LENGTH
	DEC HL
	PUSH HL				;SAVE RETURN VALUE
	OR 80H				;SET NUMBER FLAG
	LD (HL),A			;INSERT LEADING FLAG BYTE
	LD B,0
	ADD HL,BC
	DEC HL
	LD (HL),C			;INSERT TRAILING TAG BYTE
	INC HL
	LD (HEAPTR),HL		;NEW HEAP PTR
	CALL MCHKHL
	POP HL
	RET

BOXZERO:
	LD HL,ZERO			;RETURN ZERO
	RET

;*****************;
; CHARACTER INPUT ;
;*****************;

GTNONW:
	CALL SKIPW		;SKIP WHITE SPACE AND GET NEXT CHAR
;******************************;
; CHAR IN FROM CURRENT CHANNEL ;
;******************************;
GETCHR:
	.echoln "getchr ",$
	PUSH HL
	PUSH BC
	CALL CHRIN
	LD HL,NXTCHR
	LD E,(HL)		;GET LAST
	LD (HL),A		;SAVE NEXT
	LD A,E
	POP BC
	POP HL
	RET
OPEN0:
	PUSH DE
	JR OPEN1
OPEN:
.echoln "open ",$
	PUSH DE			;SAVE CHANNEL AS RETURN VALUE
	CALL OPCHAN		;SET FILE ADR
OPEN1:
;	PUSH DE
;	INC DE			;TO FCB
;	INC DE
;	CALL MLST
;	POPLIST
	call FFCB
	pop hl
	ret
OPEN10:
	BDOS(15)		;OPEN
	CP 0FFH			;ERROR?
	POP HL
	JR Z,OPNERR
	LD (HL),1		;SET READ OPEN
OPNRET:
	INC HL
	LD (HL),0		;FILE PTR := 0
	POP HL
	RET

OPEN2:
	PUSH DE			;DUMMY PUSH
	PUSH DE			;PUSH FILE ADR
	INC DE			;TO FCB
	INC DE
	JR OPEN10

OPCHAN:
	CALL FADRDE		;SET FILE ADR
	ret
;	LD A,(DE)		;GET FLAG
;	AND 3			;ALREADY OPEN?
;	RET Z			;NO
OPNERR:
	ERROR("Open")

CREAT0:
	PUSH DE
	JR CREAT1
CREATE:
	PUSH DE			;SAVE CHANNEL AS RETURN VALUE
	CALL OPCHAN
CREAT1:
	PUSH DE
	INC DE			;TO FCB
	INC DE
	CALL FFCB
	PUSH DE
	BDOS(19)		;DELETE
	POP DE
	BDOS(22)		;MAKE
	CP 0FFH			;ERROR?
	POP HL
	JR Z,CRTERR
	LD (HL),2		;SET WRITE OPEN
	JR OPNRET

FILERR:
	ERROR("File")

CRTERR:
	ERROR("Create")

CLOSE:
	LD A,H			;IGNORE CONSOLE CLOSE
	OR A
	RET Z
	PUSH HL			;SAVE CHANNEL AS RETURN VALUE
	CALL FADRMN		;CHANNEL IN DE
	EX DE,HL		;FILE IN HL
CLOSE0:
	BIT 1,(HL)		;OPEN FOR WRITING?
	JR NZ,{+}		;YES
	BIT 0,(HL)		;OPEN FOR READING?
	JR NZ,CL20		;NO
	JR CLRET
+:
	CALL WRREC		;FLUSH
CL20:
	LD (HL),0		;CLEAR FLAGS
	EX DE,HL
	INC DE			;TO FCB
	INC DE
	BDOS(16)		;CLOSE
CLRET:
	POP HL
	RET

GETC0:
	.echoln "getc0 ",$
	push de
	ld e,(hl)
	inc hl
	ld d,(hl)
	ld a,(de)
	inc de
	ld (hl),d
	dec hl
	ld (hl),e
	ld hl,TokenTable
	ld bc,CharTable-KeyTable
	push bc
	cpir
	pop bc
	add hl,bc
	add hl,bc
	dec hl
;	dec hl
	ld a,(hl)
	pop de
	ret
	BIT 0,(HL)		;OPEN FOR READING?
	JR Z,FILERR		;NO
	CALL RDREC		;READ RECORD
	INC HL
	LD E,(HL)		;GET COUNT
	LD D,0			;BYTE OFFSET IN DE
	DEC HL			;RESTORE FILE ADR
	CALL INCRFP		;INCREMENT RANDOM FILE PTR
	ADD HL,DE		;ADD BYTE OFFSET
	LD DE,38		;AND BUFFER OFFSET TO FILE ADR
	ADD HL,DE
	LD A,(HL)		;GET CHAR FROM BUFFER
	RET

PUTC0:
	BIT 1,(HL)		;OPEN FOR WRITING?
	JR Z,FILERR		;NO
	BIT 0,(HL)		;OPEN ALSO FOR READING?
	JR Z,PC10
	PUSH AF
	CALL RDREC		;YES: READ RECORD
	POP AF
PC10:
	PUSH HL
	INC HL
	LD E,(HL)		;GET COUNT
	LD D,0			;BYTE OFFSET IN DE
	ADD HL,DE		;ADD BYTE OFFSET
	LD DE,37		;AND BUFFER OFFSET TO FILE ADR
	ADD HL,DE
	LD (HL),A		;PUT CHAR IN BUFFER
	POP HL
	SET 3,(HL)		;SET WRITTEN
;INCREMENT RANDOM FILE PTR
INCRFP:
	INC HL			;TO COUNT
	INC (HL)		;INCREMENT
	DEC HL
	RET P			;RETURN IF < 128
	INC HL
	LD (HL),0		;RESET COUNT
	DEC HL
	PUSH DE			;SAVE DE
	CALL WRREC		;WRITE RECORD
	PUSH HL
	LD DE,35		;OFFSET TO R0
	ADD HL,DE
	INC (HL)		;INCREMENT RANDOM RECORD
	JR NZ,IR10
	INC HL	
	INC (HL)
IR10:
	POP HL
	POP DE
	RES 2,(HL)		;CLEAR LOADED
	RET

;******************;
; SKIP WHITE SPACE ;
;******************;
SKIPW:
	LD A,(NXTCHR)
	cp ' '+1
;	CP 33				;NEXT CHAR WHITE?
	JR NC,SW20			;NO-JMP
SW10:
	CALL CHRIN			;TRY NEXT
	OR A				;VACUUM?
	JP Z,READERR
	CP ' '+1;33
	JR C,SW10
	LD (NXTCHR),A		;SAVE THE NONWHITE CHAR
SW20:
	CP '['				;TEST FOR COMMENT
	RET NZ				;RETURN IF NOT
	CALL SKIPCOMM
	LD (NXTCHR),A		;SAVE NEXT
	JR SKIPW			;AND TRY AGAIN

SKIPCOMM:
	CALL CHRIN
SK10:
	CP 26				;END OF FILE?
	JP Z,READERR		;YES
	CP ']'				;END OF COMMENT?
	JR Z,CHRIN			;YES RETURN NEXT CHAR
	CP '['				;NESTED COMMENTS?
	JR NZ,SKIPCOMM		;NO
	CALL SKIPCOMM
	JR SK10

CHRIN:
	LD HL,(IOCHAN)
	LD A,H
	OR A
	JR Z,CIN		;CONSOLE IN
	;LD A,(HL)
	;OR A			;OPEN?
	JP NZ,GETC0		;YES
	JP FILERR

;***************;
; CONSOLE INPUT ;
;***************;
CIN:
;	ld hl,LBUF
;	ld b,127
;	call StringInput
;	di
;	ret
;	jr CONIN
	LD A,(LDFLG)
	OR A				;LOAD?
	JR Z,CONIN			;NO
	LD HL,DFLTF			;DEFAULT FILE
	CALL GETC0			;GET CHAR
	CP 0;EOFCHR			;END OF FILE?
	RET NZ				;NO
	CALL INIBUF			;CLEAR BUFFER
CONIN:
	LD HL,(LBP)			;GET LINE BUFFER PTR
	LD A,(HL)			;GET CHAR
	OR A				;END OF LINE?
;	ret z
	JR Z,CI10			;YES
	INC HL				;ELSE INC LBP
	LD (LBP),HL
	RET
CI10:
	LD A,(LEVEL)		;DISPLAY LEVEL
	CP '0'				;IF NOT ZERO
	JR Z,CI15
	CALL CHROUT
CI15:
;	BDOS(11)			;CHECK CONSOLE STATUS
;	OR A				;CHAR PRESENT?
;	JR Z,CI17			;NO
;	BDOS(1)				;ELSE DROP IT
CI17:
	PRINT (":")			;AND PROMPT)
	LD HL,LBUF			;HL ON BEGINNING OF LINE BUFFER
	LD C,0				;CLEAR CHAR COUNT
	ld b,127
	call StringInput
CI20:
;	CALL $KEY			;DIRECT CONSOLE IN
;	JR Z,CI20
	CP 13				;RETURN?
	JR NZ,CI30
	LD (HL),A			;STORE THE CR
	INC HL
	LD A,LLEN+1			;CLEAR REST
	SUB C
	LD B,A
	XOR A
CI25:
	LD (HL),A
	INC HL
	DJNZ CI25
	LD HL,LBUF
	LD (LBP),HL
	CALL CR_LF
	JR CONIN
CI30:
	CP 'H'-'@'			;BACKSPACE?
	JR NZ,CI40
	LD A,C				;TEST COUNT
	OR A
	JR Z,CI20			;DO NOTHING IF ZERO
	CALL DOBS
	JR CI20
CI40:
	CP 'X'-'@'			;^X
	JR NZ,CI50
CI45:
	LD A,C				;KILL LINE
	OR A
	JR Z,CI20
	CALL DOBS
	JR CI45
CI50:
	CP 'I'-'@'			;TAB
	JR NZ,CI60
	LD B,4				;EXPAND TO 4 SPACES
CI55:
	LD A,' '
	CALL ECHO
	DJNZ CI55
	JR CI20
CI60:
	CP 'R'-'@'			;^R
	JR NZ,CI70
CI65:
	LD A,(HL)			;RETYPE
	OR A
	JR Z,CI20
	CP 13
	JR Z,CI20
	CALL ECHO2
	JR CI65
CI70:
	CP 'C'-'@'			;^C
	JP Z,RESET
CI80:
	CALL ECHO			;ANY OTHER CHARACTER
	JR CI20

ECHO:
	LD (HL),A			;STORE CHAR
	LD A,C
	CP LLEN				;CHECK OVERFLOW
	RET NC
ECHO2:
	INC C
	LD A,(HL)			;GET CHAR AGAIN
	CP ' '				;WHITE?
	JR NC,EC10			;NO
	LD A,'_'			;ELSE MAKE PRINTABLE
EC10:
	INC HL
	JR CHROUT			;PRINT (IT)

DOBS:
	DEC C
	DEC HL
	LD A,8				;OUT BACKSPACE
	CALL CHROUT
	CALL SPACE			;OUT SPACE
	LD A,8				;OUT BACKSPACE
	JR CHROUT

;OUT SPACE
SPACE:
	LD A,32
	JR CHROUT

;MESSAGE OUT
MSG_PC:
	EX (SP),HL			;RETURN ADDRESS IN HL
	CALL PR$HL			;PRINT (STRING)
	EX (SP),HL			;NEW RETURN ADDRESS
;OUT NEWLINE SEQUENCE
CR_LF:
	B_CALL(_NewLine)
	ret
	LD A,13				;CARRIAGE RETURN
	CALL CHROUT
	LD A,10				;LINE FEED
;***************;
; CHARACTER OUT ;
;***************;
CHROUT:
	PUSH HL
	PUSH BC
	PUSH AF
	LD HL,(IOCHAN)
	LD A,H
	OR A
	JR Z,COUT		;CONSOLE OUT
	LD A,(HL)
	OR A			;OPEN?
	JP Z,FILERR		;NO
	POP AF
	CALL PUTC0
	JR CORET

COUT:
	POP AF
;;	CP 'I'-'@'
;;	JR Z,TABOUT
	LD E,A			;CHAR
	B_CALL(_PutC)
;	BDOS(2)			;CONSOLE OUT
CORET:
	POP BC
	POP HL
	RET

;;TABOUT:
;;	LD BC,0402H		;OUT 4 SPACES TO BDOS 2
;;TO10:
;;	PUSH BC
;;	LD E,' '
;;	CALL 5
;;	POP BC
;;	DJNZ TO10
;;	JR CORET

;****************;
; PRINT (ROUTINES ;)
;****************;
;PRINT (STRING AT PC)
PR_PC:
	EX (SP),HL			;RETURN ADDRESS IN HL
	CALL PR$HL			;PRINT (STRING)
	EX (SP),HL			;NEW RETURN ADDRESS
	RET

;PRINT (STRING AT HL)
PR$HL:
	B_CALL(_PutS)
	ret
	LD A,(HL)			;NEXT CHAR
	AND 7FH
	CALL CHROUT			;CHAR OUT
	BIT 7,(HL)
	INC HL				;NEXT
	RET NZ
	JR PR$HL

PUTC:
	B_CALL(_PutC)
	ret
;	PUSH HL			;RETURN VALUE
;	CALL FADRDE		;SET CHANNEL NO
	LD (IOCHAN),DE
	CALL MBYTE
	
;	CALL CHROUT

	JR PRET1

GETC:
	.echoln "getc ",$
	CALL FADRHL		;SET CHANNEL NO
	LD (IOCHAN),DE
	CALL CHRIN
	LD L,A
	LD H,0
	CALL SELCON
	JP BOXHL

;TOP LEVEL PRINT
PRINT:
.echoln "print ", $
	PUSH HL			;SAVE ARG
	PUSH DE			;AND CHANNEL
	CALL PRIN1		;PRINT (ARG)
	POP HL			;AND A NEWLINE
;	pop de
;	jp selcon
	CALL CRLF
	JR PRET1

CRLF:
	CALL FADRHL		;SET CHANNEL NO
	LD (IOCHAN),DE
	CALL CR_LF		;PRINT (NEWLINE SEQUENCE)
	JR PRET2

SPC:
	CALL FADRHL		;SET CHANNEL NO
	LD (IOCHAN),DE
	CALL SPACE		;PRINT (SPACE)
	JR PRET2

PRIN1:
	CALL FADRDE		;SET CHANNEL NO
	LD (IOCHAN),DE
	PUSH HL
	CALL PRIN0		;PRINT (ARG)
PRET1:
	POP HL
PRET2:
	JP SELCON

;PRINT NIL
PRNIL:
	PRINT ("nil")
	RET

;PRINT (ARGUMENT IN HL)
PRIN0:
	LD A,H				;NIL?
	OR A
	JR Z,PRNIL			;YES
	LD A,(HL)			;GET TAG
	RRCA				;CELL?
	JR C,PRCELL			;YES
PRATOM:
	LD A,(HL)			;GET TAG
	RLCA				;NUMBER?
	JR C,PRNUM			;YES
	LD BC,9				;OFFSET TO NAME
	ADD HL,BC
	JR PR$HL			;PRINT (SYMBOL)
PRCELL:
	PRINT ('(')			;LIST OR DOTTED PAIR
PRBODY:
	LD E,(HL)			;CAR
	INC HL
	LD D,(HL)
	INC HL
	PUSH HL				;PUSH PTR TO CDR
	EX DE,HL
	CALL PRIN0			;PRINT (CAR)
	POP HL				;RETRIEVE CDR
	LD A,(HL)
	OR A				;NIL?
	JR Z,PB20			;YES
	LD D,A
	INC HL
	LD E,(HL)
	EX DE,HL			;CDR IN HL
	LD A,(HL)
	RRCA				;CELL?
	JR NC,PB10			;NO
	CALL SPACE
	PUSH HL
	CALL BRKEY			;CHECK CONSOLE BREAK
	POP HL
	JR NC,PRBODY		;PRINT (REST OF LIST)
	PRINT ("...")			;ELSE EXIT IF BREAK
	JR PB20
PB10:
	PRINT (" . ")			;DOTTED PAIR
	CALL PRATOM
PB20:
	PRINT (')')			;DONE
	RET

PRNUM:
	INC HL				;INC TO NUMBER
	EX DE,HL
	LD HL,(HEAPTR)		;MOVE TO HEAP
	CALL MOOV
	PUSH HL
	LD BC,MAXNUM+1		;OFFSET TO WORKSPACE
	ADD HL,BC
	LD (HL),0			;INIT WORKSPACE TO ZERO
	EX (SP),HL
	LD A,(HL)			;SIGN?
	RLA
	JR NC,PN10			;NO
	SRL A				;CLEAR SIGN
	LD (HL),A
	PRINT ('-')			;PRINT (IT)
PN10:
	LD A,(HL)
	OR A				;CONVERSION DONE?
	JR Z,PN20			;YES
	EX DE,HL			;DE ON HEAP
	LD HL,BASE
	CALL MOD0			;SPLIT OFF NEXT DIGIT
	EX DE,HL
	INC HL
	LD A,(HL)			;DIGIT
	DEC HL
	EX (SP),HL			;POINT TO WORKSPACE
	CALL PSHL			;PUSH DIGIT
	EX (SP),HL
	LD DE,T2			;GET RESULT
	CALL MOOV
	JR PN10
PN20:
	POP HL				;TO WORKSPACE
	LD A,(HL)			;GET COUNT
	OR A				;ZERO?
	JR NZ,PN30			;NO
	PRINT ("0")			;ELSE OUTPUT ZERO
	RET
PN30:
	LD B,A				;COUNT
PN40:
	push bc
	INC HL
	LD A,(HL)			;GET NEXT DIGIT
	ADD A,'0'			;MAKE ASCII
	CP '9'+1
	JR C,PN50
	ADD A,7
PN50:
;	CALL CHROUT			;PRINT (DIGIT)
	B_CALL(_PutC)
	pop bc
	DJNZ PN40			;REPEAT
	RET

	END
