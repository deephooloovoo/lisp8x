;FSUBR.MAC
;@ 86/07/15

;.INCLUDE 8KLISP.DEF

;	EXTRN EVAL,EVALDE,EVBODY,HEAP,ONEADD,ONESUB,T1,T2,GC,MEMTOP
;	EXTRN CONS,SET,SET0,NILRET,FBASE,CBASE,STKSAV,SAVSYS,ERR,NILCONS
;	EXTRN MLST,MLSTDE,MSYM,MSYMDE,MNUM,MNUMDE,MBYTE,UNBOX,CREAT0,BOXL,FFCB
;	EXTRN LDFLG,OPEN0,OPEN1,GSEED,HEAPTR,MCHKHL,PUTC0,GETC0,CLOSE0

FSUBR:

QUOTE:
	FETCH			;CAR OF ARGUMENT LIST
	RET

INC:
	FETCH			;GET SYMBOL
	CALL MSYM
	PUSH HL			;SAVE IT
	INC HL
	FETCH			;VALUE
	CALL ONEADD		;INCREMENT IT
	JR SETQ2

DEC:
	FETCH			;GET SYMBOL
	CALL MSYM
	PUSH HL			;SAVE IT
	INC HL
	FETCH			;VALUE
	CALL ONESUB		;INCREMENT IT
	JR SETQ2

SETQ:
	POPLIST
	PUSH DE			;SAVE FIRST ARG
	FETCH			;CAR OF RESTLIST
	CALL EVAL		;EVALUATE SECOND ARG
SETQ2:
	EX DE,HL
	POP HL			;GET FIRST ARG
	JP SET

;SET UP CATCH FRAME
CATCH:
	LD DE,(FBASE)	;PUSH FRAME BASE
	PUSH DE
	LD DE,(CBASE)	;AND CATCH BASE
	PUSH DE
	POPLIST			;GET TAG IN DE
	PUSH HL			;SAVE BODY
	LD HL,0			;GET STACK PTR
	ADD HL,SP
	LD (CBASE),HL	;STORE AS NEW CATCH BASE
	CALL EVALDE		;EVALUATE TAG
	EX (SP),HL		;AND SAVE IT
	CALL EVBODY		;EXECUTE BODY
	POP DE			;NO THROW WAS EXECUTED, DROP TAG
	POP DE			;RESTORE CATCH BASE
	LD (CBASE),DE
	POP DE
	LD (FBASE),DE	;AND FRAME BASE
	RET

OBLIST:
	LD HL,HEAP		;HL ON FIRST SYMBOL
	LD DE,NIL		;RESULT IN DE
OL10:
	PUSH HL
	CALL CONS
	EX DE,HL		;RESULT SO FAR
	POP HL			;LAST SYMBOL
	LD BC,7			;OFFSET TO HLINK
	ADD HL,BC
	FETCH
	LD A,H			;DONE?
	OR A
	JR NZ,OL10		;NO
	EX DE,HL		;RESULT
	RET

GENSYM:
	LD HL,GSEED+5	;INCREMENT GENSYM SEED
	LD B,5			;MAX 5 DIGITS
GS10:
	LD A,(HL)		;GET DIGIT
	INC A			;INCREMENT IT
	LD (HL),A
	CP '9'+1		;OVERFLOW?
	JR C,GS20		;NO
	LD (HL),'0'		;ELSE RESET DIGIT
	DEC HL			;AND GO TO NEXT HIGHER ONE
	DJNZ GS10
GS20:
	LD HL,GSEED-1
	LD B,6			;GENSYM SIZE
CPYSYM:
	LD A,B			;LENGTH ZERO
	OR A
	JP Z,NILRET		;YES
	PUSH HL			;SAVE PTR
	LD HL,(HEAPTR)
	LD DE,8			;OFFSET TO PNAME-1
	ADD HL,DE
	POP DE
CS10:
	INC DE
	LD A,(DE)		;MOVE NAME
	INC HL
	LD (HL),A
	DJNZ CS10
	SET 7,(HL)		;MARK END OF NAME
;MAKE SYMBOL
MKSYM:
	LD HL,(HEAPTR)
	PUSH HL			;SAVE HEAPTR
	XOR A
	INC HL
	LD (HL),A		;SET UNBOUND
	INC HL
	LD (HL),A
	LD B,3			;NIL IN FUNDEF, PLIST AND HLINK
MS10:
	INC HL
	LD (HL), LOW(NIL)
	INC HL
	LD (HL),A		;HIGH(NIL)
	DJNZ MS10
	LD C,10+3		;EMPTY SYMBOL SIZE + ADJUSTMENT
	LD A,MAXSYM+13+1;NAME SIZE LIMIT
MS20:
	INC C			;INCREMENT COUNT
	CP C			;SIZE OK?
	JR Z,NAMERR		;NO
	INC HL			;FIND END OF NAME
	BIT 7,(HL)
	JR Z,MS20
	LD A,C			;GET SIZE
	AND 0FCH		;ADJUST TO MULTIPLE OF 4
	LD C,A
	POP HL			;GET HEAPTR
	PUSH HL
	LD (HL),A		;INSERT LEADING FLAG BYTE
	ADD HL,BC		;(BC=0 SINCE DJNZ)
	LD (HEAPTR),HL	;SAVE NEW HEAPTR
	DEC HL
	LD (HL),A		;INSERT TRAILING FLAG BYTE
	INC HL
	CALL MCHKHL
	POP HL			;SYMBOL'S ADDRESS
	RET

NAMERR:
	ERROR("Size")



$KEY:

	PUSH HL
	PUSH BC
	B_CALL(_getkey)
	di
	pop bc
	pop hl
	ret
ValidKeyLoop:
	ei
	B_CALL(_getkey)
	di
	ld hl,KeyTable
	ld bc,CharTable-KeyTable
	push bc
	cpir
	pop bc
	jr nz, ValidKeyLoop
	add hl,bc
	dec hl
	ld a, (hl)
;	LD E,0FFH		;INPUT REQUEST
;	BDOS(6)
;	OR A
	POP BC
	POP HL
	RET

;REDIRECT INPUT
IN:
	PUSH HL			;SAVE FILE NAME AS RETURN VALUE
	LD A,1			;SET LOAD FLAG
	LD (LDFLG),A
	LD DE,DFLTF		;DEFAULT FILE
	JP OPEN1

;SNAPSHOT
SAVE:
	PUSH HL			;SAVE NAME AS RETURN VALUE
	CALL GC			;COMPACT HEAP
	POP HL
	PUSH HL
	LD DE,T1		;FILE ADR
	CALL CREAT0
	LD HL,0			;SAVE STACK PTR
	ADD HL,SP
	LD (STKSAV),HL	;IN STKSAV
	LD HL,SAVSYS	;WRITE DATA AND HEAP
	LD DE,(HEAPTR)
	CALL SAV0
	LD HL,(STKSAV)	;WRITE STACK AND FILES
	LD DE,(MEMTOP)
	CALL SAV0
SAVRET:
	LD HL,T1
	JP CLOSE0

SAV0:
	PUSH HL			;START ADR
	PUSH DE			;END ADR
	LD A,(HL)		;GET CHAR
	LD HL,T1		;FILE
	CALL PUTC0		;CHARACTER OUT
	POP DE
	POP HL
	INC HL			;DONE?
	CPDE
	JR NZ,SAV0		;NO
	RET

BADUMP:
	ERROR("Load")

LOAD:
	LD DE,T1		;FILE ADR
	CALL OPEN0
	CALL LDWORD		;GET HEADER
	LD HL,"K8"
	CPDE			;ILLEGAL HEADER?
	JR NZ,BADUMP	;YES
	CALL LDWORD		;GET MEMTOP
	LD HL,(MEMTOP)
	CPDE			;SAME?
	JR NZ,BADUMP	;NO
	CALL LDWORD		;GET HEAPTR
	LD (HEAPTR),DE	;SAVE IT
	LD HL,SAVSYS+6	;LOAD DATA AND HEAP
	CALL LOD0
	LD HL,T2+128	;MOVE SP OUT OF THE WAY
	LD SP,HL
	LD HL,(STKSAV)	;WRITE STACK AND FILES
	LD DE,(MEMTOP)
	CALL LOD0
	LD HL,(STKSAV)	;RESTORE SP
	LD SP,HL
	JR SAVRET

LOD0:
	PUSH HL			;START ADR
	PUSH DE			;END ADR
	CALL LODC		;CHARACTER IN
	POP DE
	POP HL
	LD (HL),A		;WRITE CHAR
	INC HL			;DONE?
	CPDE
	JR NZ,LOD0		;NO
	RET

LODC:
	LD HL,T1
	JP GETC0

LDWORD:
	CALL LODC
	PUSH AF
	CALL LODC
	LD D,A			;RETURN WORD IN DE
	POP AF
	LD E,A
	RET

;DIRECTORY FUNCTION
DIR:
	LD DE,T1		;SPACE FOR FCB
	CALL FFCB		;FORMAT FCB
	LD DE,T2		;SPACE FOR DMA
	BDOS(26)			;SET DMA
	LD DE,T1
	BDOS(17)		;SEARCH FOR FIRST
	LD HL,NIL		;DEFAULT IF NOT FOUND
	CP 255
	RET Z
	CALL GFNAM		;GET FIRST FILE NAME
	CALL NILCONS	;MAKE LIST
DIR10:
	PUSH HL			;SAVE IT
	LD DE,T1
	BDOS(18)			;SEARCH FOR NEXT
	POP HL			;GET DIRECTORY LIST SO FAR
	CP 255
	RET Z			;RETURN IF NO MORE FOUND
	PUSH HL
	CALL GFNAM		;GET NEXT FILE NAME
	POP DE
	CALL CONS		;CONS INTO FILE LIST
	JR DIR10

;GET FILE NAME
GFNAM:
	LD DE,T2+1		;RECORD WITH DIRECTORY ENTRY
	ADD A,A			;CALCULATE STARTING POSITION
	ADD A,A
	ADD A,A
	ADD A,A
	ADD A,A
	LD L,A
	LD H,0
	ADD HL,DE		;HL ON FILE NAME
	PUSH HL			;SAVE PTR TO FILE NAME
	LD B,8
	CALL MKNAME		;GET FILE NAME
	EX (SP),HL
	LD DE,8			;TO FILE EXTENSION
	ADD HL,DE
	LD B,3			;MEASURE EXTENSION'S LENGTH
	CALL MKNAME
	CALL NILCONS	;LIST EXTENSION
	EX DE,HL
	POP HL			;CONS FILE NAME
	JP CONS

;RETURN LENGTH OF FILE NAME PART
MKNAME:
	PUSH HL			;PRESERVE HL
	LD C,0			;INIT COUNT
NL10:
	LD A,(HL)
	CP ' '			;BLANK IS END OF NAME
	JR Z,NL20
	INC C
	INC HL
	DJNZ NL10
NL20:
	LD B,C
	POP HL
	DEC HL
	JP CPYSYM

;******************;
; STACK OPERATIONS ;
;******************;
PUSH:
	POPLIST			;ARG IN DE
	FETCH			;SYMBOL IN HL
	CALL MSYM
	PUSH HL			;SAVE SYMBOL
	CALL EVALDE		;EVALUATE ARG
	EX DE,HL		;VALUE IN DE
	POP HL			;GET SYMBOL
	PUSH HL
	INC HL			;GET VALUE
	FETCH
	EX DE,HL
	CALL CONS
	EX DE,HL
	POP HL			;RETRIEVE SYMBOL
	JP SET

POP:
	FETCH			;GET SYMBOL
	CALL MSYM
	INC HL
	PUSH HL			;SAVE PTR TO VALUE
	FETCH			;GET VALUE
	CALL MLST
	POPLIST			;POP IT
	EX DE,HL		;REST IN DE
	EX (SP),HL		;SAVE RETURN VALUE, GET VALUE PTR
	JP PUT2

;*******************************;
; MAKE A LIST OF EVALUATED ARGS ;
;*******************************;
LIST:
	LD A,H			;ARGS EMPTY?
	OR A
	RET Z			;YES
	POPLIST
	PUSH HL			;SAVE CDR
	CALL EVALDE		;EVAL CAR
	EX (SP),HL		;SAVE RESULT, GET CDR
	CALL LIST		;RECURSE ON CDR
	EX DE,HL
	POP HL
	JP CONS

;*******************;
; DEFINE A FUNCTION ;
;*******************;
DEFUN:
	POPLIST			;SYMBOL IN DE, BODY IN HL
	EX DE,HL
DOPUTD:
	CALL MSYM
	PUSH HL			;SAVE SYMBOL
	LD A,(DE)		;SECOND ARG
	AND 81H
	CP 80H			;NUMBER?
	JR NZ,PUT0		;NO
	EX DE,HL		;ELSE GET IT
	INC HL
	INC HL
	LD A,(HL)
	INC HL
	LD H,(HL)
	LD L,A
	EX DE,HL
PUT0:
	INC HL			;SET FUNCTION DEFINITION
	INC HL
PUT1:
	INC HL
PUT2:
	LD (HL),E
	INC HL
	LD (HL),D
	POP HL			;RETURN SYMBOL
	RET
	
;**************;
; PROGRAM FLOW ;
;**************;
L_AND:
	POPLIST			;NEXT FORM
	PUSH HL			;SAVE REST
	CALL EVALDE
	POP DE			;RETRIEVE REST
	LD A,H			;FORM NIL?
	OR A
	RET Z			;YES - RETURN NIL
	LD A,D			;REST EMPTY?
	OR A
	RET Z			;YES - RETURN LAST RESULT
	EX DE,HL
	JR L_AND

L_OR:
	POPLIST			;NEXT FORM
	PUSH HL			;SAVE REST
	CALL EVALDE
	POP DE			;RETRIEVE REST
	LD A,H			;FORM NIL?
	OR A
	RET NZ			;NO - RETURN RESULT
	EX DE,HL
	LD A,H			;REST EMPTY?
	OR A
	RET Z			;YES - RETURN NIL
	JR L_OR

PROG2:
	POPLIST
	PUSH HL
	CALL EVALDE
	POP HL
PROG1:
	POPLIST
	PUSH HL
	CALL EVALDE		;EVAL FIRST EXPRESSION
	EX (SP),HL		;SAVE RESULT
	CALL EVBODY		;EVAL REST
	POP HL			;RETURN FIRST VALUE
	RET

PROGN:
	JP EVBODY

WHILE:
	POPLIST			;CONDITION IN DE, BODY IN HL
	PUSH DE
	PUSH HL
	LD BC,NIL		;DEFAULT RETURN VALUE
	PUSH BC
WH10:
	CALL EVALDE		;CONDITION FALSE?
	LD A,H
	OR A
	JR Z,WHRET		;YES
	POP BC			;ELSE DROP LAST RETURN VALUE
	POP HL			;EVALUATE BODY
	PUSH HL
	CALL EVBODY
	POP BC			;BODY
	POP DE			;CONDITION
	PUSH DE
	PUSH BC
	PUSH HL			;NEW RETURN VALUE
	JR WH10
WHRET:
	POP HL			;GET RETURN VALUE
	POP DE			;DROP BODY
	POP DE			;DROP ARGS
	RET
IF:
.echoln "if ",$
	POPLIST
	push hl		;body
	call EVALDE	;condition
	ld a,h
	or a
	pop hl		;body
	jr z,IF10
	POPLIST
	ex de,hl
;	call EVAL
	ret
IF10:
	POPLIST
	ld a,h
	or a
	ret z
	call EVBODY
	ret
WHEN:
	POPLIST
	push hl
	call EVALDE
	ld a,h
	or a
	pop hl
	jp nz, EVBODY
WHEN10:
	ld hl, NIL
	ret
UNLESS:
	POPLIST
	push hl
	call EVALDE
	ld a,h
	or a
	pop hl
	jp z, EVBODY
	jr WHEN10
UNTIL:
	POPLIST			;CONDITION IN DE, BODY IN HL
	PUSH HL			;SAVE BODY
	PUSH DE			;SAVE CONDITION
UT10:
	CALL EVBODY		;EVAL BODY AT LEAST ONCE
	POP DE			;RETRIEVE CONDITION
	PUSH DE
	PUSH HL			;SAVE RETURN VALUE
	CALL EVALDE		;CONDITION TRUE?
	LD A,H
	OR A
	JR NZ,WHRET		;YES
	POP BC			;ELSE DROP LAST RETURN
	POP DE			;CONDITIONAL
	POP HL			;BODY
	PUSH HL
	PUSH DE
	JR UT10

REPTN:
	POPLIST			;COUNT IN DE
	PUSH HL			;SAVE BODY
	CALL EVALDE		;EVAL COUNT
	CALL UNBOX
	LD A,D			;COUNT ZERO?
	OR E
	OR C
	JR Z,RPTNIL		;YES: RETURN NIL
	LD L,D			;MSB IN L
	XOR A
	LD H,A
	LD D,A			;UPPER BYTES ZERO FOR GC
	LD B,A
	SUB C			;NEGATE COUNT
	LD C,A
	LD A,B			;(ZERO)
	SBC A,E
	LD E,A
	LD A,B
	SBC A,L
	LD L,A
	EXX
	POP HL			;RETRIEVE BODY
	EXX
	PUSH HL
	PUSH DE
	PUSH BC			;COUNTS IN (SP)
	EXX
RPT10:
	PUSH HL
	CALL EVBODY
	POP DE			;GET BODY
	EXX
	POP BC			;AND COUNT
	INC C			;DONE?
	JR NZ,RPT30		;NO
	POP DE
	INC E
	JR NZ,RPT20		;NO
	POP HL
	INC L
	JR Z,RPTRET		;YES
	PUSH HL
RPT20:
	PUSH DE
RPT30:
	PUSH BC
	EXX
	EX DE,HL		;BODY IN HL
	JR RPT10
RPTRET:
	EXX				;RETURN LAST RESULT
	RET
RPTNIL:
	POP HL			;DROP BODY
	JP NILRET

DO:
	POPLIST			;GET VAR
	CALL MSYMDE		;SYMBOL IN HL, REST IN DE
	PUSH HL			;SAVE SYMBOL
	EX DE,HL
	POPLIST			;INITEX IN DE
	PUSH HL			;SAVE REST
	CALL EVALDE		;INITIAL VALUE
	EX DE,HL		;IN DE
	POP BC			;RETRIEVE REST
	POP HL			;AND SYMBOL
	PUSH HL
	INC HL			;VALUE CELL
	LD (HL),E		;SET NEW
	INC HL
	LD (HL),D
	LD H,B			;GET REST
	LD L,C
	POPLIST
	PUSH DE			;SAVE CONDITION
	POPLIST
	PUSH DE			;SAVE RE-INIT EXPR
	PUSH HL			;SAVE BODY
	LD HL,NIL		;DEFAULT RETURN VALUE
	PUSH HL			;SAVE RETVAL
DO10:
	LD HL,6			;GET CONDITION
	ADD HL,SP
	LD A,(HL)
	INC HL
	LD H,(HL)
	LD L,A
	CALL EVAL		;EVAL IT
	LD A,H
	OR A			;TRUE?
	JR Z,DO20		;NO
	POP HL			;ELSE DROP LAST RETVAL
	POP HL			;GET BODY
	PUSH HL
	CALL EVBODY		;EXECUTE BODY
	PUSH HL			;SAVE RETURN VALUE
	LD HL,4			;GET RE-INIT EXPR
	ADD HL,SP
	LD A,(HL)
	INC HL
	LD H,(HL)
	LD L,A
	CALL EVAL		;EVALUATE
	EX DE,HL
	LD HL,8			;GET SYMBOL
	ADD HL,SP
	LD A,(HL)
	INC HL
	LD H,(HL)
	LD L,A
	INC HL			;SET NEW VALUE
	LD (HL),E
	INC HL
	LD (HL),D
	JR DO10
DO20:
	POP DE			;GET RETURN VALUE
	POP HL			;DROP BODY
	POP HL			;RE-INIT
	POP HL			;CONDITION
	POP HL			;AND SYMBOL
	EX DE,HL		;RETURN VALUE
	RET

;	END
